/*
    ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * @file    templates/hal_lld.c
 * @brief   HAL Driver subsystem low level driver source template.
 *
 * @addtogroup HAL
 * @{
 */

#include "ch.h"
#include "hal.h"

/*===========================================================================*/
/* Driver local definitions.                                                 */
/*===========================================================================*/

/*===========================================================================*/
/* Driver exported variables.                                                */
/*===========================================================================*/

/*===========================================================================*/
/* Driver local variables and types.                                         */
/*===========================================================================*/

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

/*===========================================================================*/
/* Driver exported functions.                                                */
/*===========================================================================*/



/* Clock settings (84MHz) */
#define SYS_BOARD_OSCOUNT   (CKGR_MOR_MOSCXTST(0x8))
#define SYS_BOARD_PLLAR     (CKGR_PLLAR_ONE \
                             | CKGR_PLLAR_MULA(0xdUL) \
                             | CKGR_PLLAR_PLLACOUNT(0x3fUL) \
                             | CKGR_PLLAR_DIVA(0x1UL))
#define SYS_BOARD_MCKR      (PMC_MCKR_PRES_CLK_2 | PMC_MCKR_CSS_PLLA_CLK)

/* Clock Definitions */
#define SYS_UTMIPLL             (480000000UL)   /* UTMI PLL frequency */

#define SYS_CKGR_MOR_KEY_VALUE  CKGR_MOR_KEY(0x37) /* Key to unlock MOR register */

/* FIXME: should be generated by sock */
uint32_t SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

/**
 * \brief Setup the microcontroller system.
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit(void) {
    /* Set FWS according to SYS_BOARD_MCKR configuration */
    EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
    EFC1->EEFC_FMR = EEFC_FMR_FWS(4);

    /* Initialize main oscillator */
    if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)) {
        PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT |
                        CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
        while (!(PMC->PMC_SR & PMC_SR_MOSCXTS)) {
        }
    }

    /* Switch to 3-20MHz Xtal oscillator */
    PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT |
                    CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;

    while (!(PMC->PMC_SR & PMC_SR_MOSCSELS)) {
    }
    PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) |
                    PMC_MCKR_CSS_MAIN_CLK;
    while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
    }

    /* Initialize PLLA */
    PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
    while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
    }

    /* Switch to main clock */
    PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
    while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
    }

    /* Switch to PLLA */
    PMC->PMC_MCKR = SYS_BOARD_MCKR;
    while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
    }

    SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void) {
    /* Determine clock frequency according to clock register values */
    switch (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) {
        case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
            if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
                SystemCoreClock = CHIP_FREQ_XTAL_32K;
            } else {
                SystemCoreClock = CHIP_FREQ_SLCK_RC;
            }
            break;
        case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
            if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
                SystemCoreClock = CHIP_FREQ_XTAL_12M;
            } else {
                SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

                switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
                    case CKGR_MOR_MOSCRCF_4_MHz:
                        break;
                    case CKGR_MOR_MOSCRCF_8_MHz:
                        SystemCoreClock *= 2U;
                        break;
                    case CKGR_MOR_MOSCRCF_12_MHz:
                        SystemCoreClock *= 3U;
                        break;
                    default:
                        break;
                }
            }
            break;
        case PMC_MCKR_CSS_PLLA_CLK: /* PLLA clock */
        case PMC_MCKR_CSS_UPLL_CLK: /* UPLL clock */
            if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
                SystemCoreClock = CHIP_FREQ_XTAL_12M;
            } else {
                SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

                switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
                    case CKGR_MOR_MOSCRCF_4_MHz:
                        break;
                    case CKGR_MOR_MOSCRCF_8_MHz:
                        SystemCoreClock *= 2U;
                        break;
                    case CKGR_MOR_MOSCRCF_12_MHz:
                        SystemCoreClock *= 3U;
                        break;
                    default:
                        break;
                }
            }
            if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
                SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >>
                                     CKGR_PLLAR_MULA_Pos) + 1U);
                SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >>
                                     CKGR_PLLAR_DIVA_Pos));
            } else {
                SystemCoreClock = SYS_UTMIPLL / 2U;
            }
            break;
    }

    if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
        SystemCoreClock /= 3U;
    } else {
        SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
                             PMC_MCKR_PRES_Pos);
    }
}

/**
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk) {
    /* Set FWS for embedded Flash access according to operating frequency */
    if (ul_clk < CHIP_FREQ_FWS_0) {
        EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
        EFC1->EEFC_FMR = EEFC_FMR_FWS(0);
    } else if (ul_clk < CHIP_FREQ_FWS_1) {
        EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
        EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
    } else if (ul_clk < CHIP_FREQ_FWS_2) {
        EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
        EFC1->EEFC_FMR = EEFC_FMR_FWS(2);
    } else if (ul_clk < CHIP_FREQ_FWS_3) {
        EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
        EFC1->EEFC_FMR = EEFC_FMR_FWS(3);
    } else if (ul_clk < CHIP_FREQ_FWS_4) {
        EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
        EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
    } else {
        EFC0->EEFC_FMR = EEFC_FMR_FWS(5);
        EFC1->EEFC_FMR = EEFC_FMR_FWS(5);
    }
}


# define MAX_PERIPH_ID    44


/** Bit mask for peripheral clocks (PCER0) */
#define PMC_MASK_STATUS0        (0xFFFFFFFC)

/** Bit mask for peripheral clocks (PCER1) */
#define PMC_MASK_STATUS1        (0xFFFFFFFF)

/** Loop counter timeout value */
#define PMC_TIMEOUT             (2048)


void pmc_enable_all_periph_clk(void) {
    PMC->PMC_PCER0 = PMC_MASK_STATUS0;
    while ((PMC->PMC_PCSR0 & PMC_MASK_STATUS0) != PMC_MASK_STATUS0);

    PMC->PMC_PCER1 = PMC_MASK_STATUS1;
    while ((PMC->PMC_PCSR1 & PMC_MASK_STATUS1) != PMC_MASK_STATUS1);
}

/**
 * \brief Disable all peripheral clocks.
 */
void pmc_disable_all_periph_clk(void) {
    PMC->PMC_PCDR0 = PMC_MASK_STATUS0;
    while ((PMC->PMC_PCSR0 & PMC_MASK_STATUS0) != 0);

    PMC->PMC_PCDR1 = PMC_MASK_STATUS1;
    while ((PMC->PMC_PCSR1 & PMC_MASK_STATUS1) != 0);
}



/**
 * \brief Enable the specified peripheral clock.
 *
 * \note The ID must NOT be shifted (i.e., 1 << ID_xxx).
 *
 * \param ul_id Peripheral ID (ID_xxx).
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id) {
    if (ul_id > MAX_PERIPH_ID) {
        return 1;
    }

    if (ul_id < 32) {
        if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
            PMC->PMC_PCER0 = 1 << ul_id;
        }
    } else {
        ul_id -= 32;
        if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
            PMC->PMC_PCER1 = 1 << ul_id;
        }
    }

    return 0;
}

/**
 * \brief Disable the specified peripheral clock.
 *
 * \note The ID must NOT be shifted (i.e., 1 << ID_xxx).
 *
 * \param ul_id Peripheral ID (ID_xxx).
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_disable_periph_clk(uint32_t ul_id) {
    if (ul_id > MAX_PERIPH_ID) {
        return 1;
    }

    if (ul_id < 32) {
        if ((PMC->PMC_PCSR0 & (1u << ul_id)) == (1u << ul_id)) {
            PMC->PMC_PCDR0 = 1 << ul_id;
        }
    } else {
        ul_id -= 32;
        if ((PMC->PMC_PCSR1 & (1u << ul_id)) == (1u << ul_id)) {
            PMC->PMC_PCDR1 = 1 << ul_id;
        }
    }
    return 0;
}



/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    WDT->WDT_MR = WDT_MR_WDDIS;
    /* Reset peripherals */    
    pmc_disable_all_periph_clk();

    SysTick_Config(SystemCoreClock / CH_FREQUENCY);

    /* DWT cycle counter enable.*/
    SCS_DEMCR |= SCS_DEMCR_TRCENA;
    DWT_CTRL  |= DWT_CTRL_CYCCNTENA;

    //dmaInit();

}

/**
 * @brief   Platform early initialization.
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function is meant to be invoked early during the system
 *          initialization, it is usually invoked from the file
 *          @p board.c.
 *
 * @special
 */
void platform_early_init(void) {

}



void sam3x8e_clock_init(void) {
    SystemInit();
}

/** @} */
